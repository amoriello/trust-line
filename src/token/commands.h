//  Author Amoriello Hutti - 2015

#ifndef SRC_TOKEN_COMMANDS_H_
#define SRC_TOKEN_COMMANDS_H_

#include <stdint.h>

/*!
 * ProtocolHeader type layout
 *
 * Common to both a command and a response, this header
 * contains information about the Command / Reponse id (id)
 * and its corresponding argument size (arg_size)
 * 
 */
#pragma pack(1)
struct ProtocolHeader {
  uint8_t id;
  uint8_t arg_size;
};
#pragma pack()


/*!
 * Command type layout
 *
 * Every commands contains a security token generated by a hmac
 * a nonce, and the command itself.
 * The security token is required for every commands that need to
 * be authenticated (see CommandId for detail)
 *
 */
#pragma pack(1)
struct Command {
  uint8_t sec_token[32];  // HMAC-SHA256(nonce + 1 | cmd)
  ProtocolHeader hdr;
  uint8_t arg[100];
};
#pragma pack()



#pragma pack(1)
struct Response {
  ProtocolHeader hdr;
  uint8_t arg[100];
};
#pragma pack()


/*!
 * Function pointer type for commands callbacks
 *
 * The comands to be executed MUST fit this prototype.
 */
typedef void (*CmdProcessor)(const Command& cmd);


namespace respid {
enum ResponseType {
  kOk,
  kPairWithDeviceFirst,
  kDeviceAlreadyPaired,
  kBadAuth,
  kInvalidCmd,
  kInvalidPassword,
  kMessage,
  kInvalidArgument
};  
}  // namespace respid



namespace cmdid {               // Need to be authenticated?
enum CommandId {                //
  kPair,                        // No
  kCreateChallenge,             // No

  kReset,                       // Yes
  kCreatePassword,              // Yes
  kTypePassword,                // Yes
  kReturnPassword,              // Yes
  kLockComputer,                // Yes
  kTypeString,

  //// TESTONLY ////
  kTestEcho,
  kTestPassword,
  kTestKey,
  kTestPasswordCrypto,
  kTestIsInitialized,
  kTestIsAuthorized,
  kTestChallenge,
  //// TESTONLY ////
  kNbCmd
};
}  // namespace cmdid


inline bool IsNoAuthCommand(const Command& cmd) {
  return cmd.hdr.id <= cmdid::kCreateChallenge;
}

inline bool IsTesting(const Command& cmd) {
  using cmdid::kTestEcho;
  using cmdid::kNbCmd;
  return cmd.hdr.id >= kTestEcho && cmd.hdr.id < kNbCmd;
}

/*!
 * Callback map that associates a CommandId the corresponding action
 * CmdProcessor.
 *
 * This tab "automatically" filled before the call for setup and loop
 * using C++ static object's constructor.
 *
 */
extern CmdProcessor g_cmd_registrer[cmdid::kNbCmd];


#endif  // SRC_TOKEN_COMMANDS_H_
